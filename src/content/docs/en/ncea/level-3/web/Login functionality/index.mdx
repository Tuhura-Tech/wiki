---
title: login functionality
description: Adding logging in to our blog
sidebar:
    order: 3
---

Todo: 
- Add username? Could use it to display who posted a post.
- Update organisation/project structure
- Add formatting for this page and search page, steps etc
- rename form.html to be a more fitting/clear name like "add_post.html" or something
- Clarity in earlier content about FastAPI requests, and the way pages are linked etc - Explain POST vs GET properly



Adding login functionality to our blog is going to be significantly more complicated than adding a search. But it'll use pretty similar things to what we've already done!

The primary new considerations will be:
1. Storing that a user is logged in (Cookies)
2. Keeping our logins secure (This is a huge topic - and we'll only be covering the basics)

Everything else is just variations on things we've done before! Which becomes pretty apparent when we break down our steps to having a login system:
1. Registration form (Similar to our post creation form)
2. Storing our registered users (Database)
3. Logging in (Comparing a form to a database)

We'll build things in the order above, as that's the order a user would experience them, an it'll make them easier to understand.

## Signup Form

We'll start by making the form the user will use to register an account.

For this, as we've done before, we'll create a new Template in our **templates** folder call it **register.html**

We'll of course want to extend from our base template and create some headings

```html
{% extends "base.html" %}

{% block title %} Register {% endblock %}

```
Then, let's make the form the user will fill in to register.

The user needs to provide an email address and a password when registering. We could, if we wanted, also allow the user to provide a username, which would be added the same way as the username (Though maybe with additional checking to ensure it's a valid email)

```html
{% block content %}
<div class="container">
  <div class="register_form">
        <form method="POST">
          <div class="input_field">
            <label>Email</label>
            <input type="text"  placeholder="email" name="email" value="{{email}}" class="form-control">
          </div>
          <div class="input_field">
            <label>Password</label>
            <input type="password" placeholder="password" name="password" value="{{password}}" class="form-control">
          </div>
          <button type="submit" class="submit_button">Submit</button>
        </form>
      </div>
    </div>
  
```

Let's also do what we did with our post creation form, and have a field that will display any errors with the users input (e.g password too short/not secure enough)

```html
    <div class="row">
      <div class="error text">
          {% for error in errors %}
            <li>{{error}}</li>
          {% endfor %}
      </div>
    </div>
  </div>
{% endblock %}
```

Giving us a **register.html** that looks like this:

```html
{% extends "base.html" %}

{% block title %} Register {% endblock %}

{% block content %}
<div class="container">
  <div class="register_form">
        <form method="POST">
          <div class="input_field">
            <label>Email</label>
            <input type="text"  placeholder="email" name="email" value="{{email}}" class="form-control">
          </div>
          <div class="input_field">
            <label>Password</label>
            <input type="password" placeholder="password" name="password" value="{{password}}" class="form-control">
          </div>
          <button type="submit" class="submit_button">Submit</button>
        </form>
      </div>
    </div>

    <div class="row">
      <div class="error text">
          {% for error in errors %}
            <li>{{error}}</li>
          {% endfor %}
      </div>
    </div>
</div>
{% endblock %}
```
Let's also quickly edit our **blog.html** to add a link to our new form (Though not it won't work until we've created the FastAPI Request)
I'll just be putting mine at the top, below the searchbar.

```html
<a href="{{url_for('signup')}}">Register</a>
```


## Verifying the data

Next, similarly to what we did for the post creation form, we should verify the data and ensure that it's been filled out correctly, and display return errors to be displayed by our form otherwise.

We'll again be defining the rules for our email and password very loosely, if you want to find out how to define proper requirments (such as needing and '@' symbol, or requiring a number in the password) have a read up on [Regex](https://regexr.com/)

Let's first create a new python filled called "login_validation.py" 

and start by importing:

```python
from fastapi import Request
from typing import List
from typing import Optional
```

Then we'll start by defining our variables

```python
class NewSignup:
    def __init__(self, request: Request):
      self.request: Request = request
      self.errors: List = []
      self.email: Optional[str] = none
      self.password: Optional[str] = none
```

Then we'll decide if the users inputs are valid, adding any issues to the Errors list, and returning True if there are no errors.

```python
  def valid_input(self):
    if not self.email or not len(self.email) >=5:
      self.errors.append("Invalid email address")
    if not self.password or not len(self.password) >= 6:
      self.errors.append("Your password must be at least 5 characters long")
    
    if not self.errors:
      return True
    else: 
      return False
```

And finally, we'll write a function that loads in the data from the form.

```python
  async def load_data(self):
    login = await self.request.form()
    self.email = form.get("email")
    self.password = form.get("password")
```

For a full script that looks like this:

```python
from fastapi import Request
from typing import List
from typing import Optional

class NewSignup:
    def __init__(self, request: Request):
      self.request: Request = request
      self.errors: List = []
      self.email: Optional[str] = None
      self.password: Optional[str] = None


  def valid_input(self):
    if not self.email or not len(self.email) >=5:
      self.errors.append("Invalid email address")
    if not self.password or not len(self.password) >= 6:
      self.errors.append("Your password must be at least 5 characters long")
    
    if not self.errors:
      return True
    else: 
      return False

  async def load_data(self):
    form = await self.request.form()
    self.email = form.get("email")
    self.password = form.get("password")
```
## User Schema

Now, we have a form where users can signup, and basic processing of their input. Let's set up the communication between these aspects, and actually storing our signups in our Database.

Let's first create a schema for our users, so that we can store them in our Database.

This'll look pretty similar to how we defined our Post schema, where we think about what we need it to contain, and any special properties we want the data to have!

The one special thing to take into account here, is that we want our email field to be **unique** i.e we don't want people to be able to register twice with the same email.

So our schema should look something like this:

```python
class User(SQLModel, table = True):
    id: int | None = Field(default = None, primary_key= True)
    email: str = Field(unique= True, nullable=False)
    password_hash: str = Field(nullable = False)
```

This is also where we could define whether a user is an admin or not, if you wanted to do something like this, you'd add a line like:

```python
is_admin: bool = Field(default= False)
```

You may notice our password field is called **password_hash.** This is because we don't want to store the plaintext of a users password! This would be *very* poor design and make much easier for someone to access users passwords from our database. Instead we store a **Hash** where the password is run through an algorithm that creates a unique string based on the output. The same input will *always* result in the same output, but it's impossible to take the output and get the input! This allows us to check that a users password is correct, and store it, in a way that is secure! 


If you want to learn more about hashing, you can read more [Here](https://en.wikipedia.org/wiki/Cryptographic_hash_function)

For our Hashing, we'll use python's built in [hashlib](https://docs.python.org/3/library/hashlib.html)

As this is a default python library, we can add this to our project by adding 

```python
import hashlib
```
To our **main.py**

## Storing Users

Lets create a new function in **main.py** create an instance of the schema.

```python
def create_user(new_email: str, new_password : str):
```

The first thing we'll want to do, is hash the password.

```python
    hasher = hashlib.sha256()
    hasher.update(new_password)
    hashed = hasher.hexdigest()
```
Here we've created a new instance of the [sha256](https://en.wikipedia.org/wiki/SHA-2) hasher, passed it the raw password, and gotten the ouput.

Then we can create an instance of the schema,

```python
    user = User(
        email = new_email,
        password_hash = hashed
    )
```
and store it in the database

```python
    with Session(engine) as session:
        session.add(user)
        session.commit()
        session.refresh(user)

    return user
```

For a full function that looks like this:

```python
def create_user(new_email : str, new_password : str):

    hasher = hashlib.sha256()
    hasher.update(new_password)
    hashed = hasher.hexdigest()

    user = User(
        email = new_email,
        password_hash = hashed
    )

    with Session(engine) as session:
        session.add(user)
        session.commit()
        session.refresh(user)
    
    return user
```

Now we have a way for the user to input signup data, and a way to store that data! All that's left to do is connect it via FastAPI Requests.

## Connecting everything

To connect everything we just need to set up our FastAPI requests!

The first one, to access our new signup page, is easy.

```python
@app.get("/signup/")
def signup(request: Request):
    return templates.TemplateResponse("signup.html", {"request": request})
```
Keep in mind, the name of this function needs to match your link on your **blog.html** and the filename needs to match the name of your signup page.

Our other function (a **Post** function, as we're modifying data) Will be slightly more complicated!

We need it to:
1. Retrieve data from the form
2. Create a new User
3. Check that the User is valid
4. Redirect to the home page

todo: break this down into step by step

```python
@app.post("/signup/")
async def signup(request: Request):
    signup = NewSignup(request)
    await signup.load_data()
    if await signup.valid_input():
        try:
            user = create_user(signup.email, signup.password)
            return RedirectResponse("blog.html", status_code=status.HTTP_302_FOUND)
        except IntegrityError:
            signup.__dict__.get("errors").append("An account with this email already exists")

            return templates.TemplateResponse("signup.html", signup.__dict__)
        
    return templates.TemplateResponse("signup.html", signup.__dict__)
```

## Cookies

## Signing in 
