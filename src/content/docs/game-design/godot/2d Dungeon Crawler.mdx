---
title: Making a 2D top down dungeon crawler
description: This page works through 2D top down dungeon crawler step-by-step
sidebar:
    order: 5
---


This is a guide to making a 2-dimensional dungeon crawling game in [Godot](https://godotengine.org/). If you are unfamiliar with Godot, check out the [Godot basics](/game-design/godot/basics) doc as this tutorial assumes basic knowledge of navigating and using the Godot Engine.

:::note[Version]
This guide is up-to-date with Godot 4.2 stable official release but will most likely work with any 4.x release.
:::

We'll be making a game in which the player explores a multi-floor dungeon in a top-down perspective. This project will include:
- Movement 
- Attacking
- Health loss & Gain 
- Pickups (Coins & Potions)
- Enemies

We will not be creating our own assets as part of this project, although you are of course welcome to!

We'll instead be using a free asset pack by Ox72 on Itch.IO which [can be found here](https://0x72.itch.io/dungeontileset-ii) Just click *Download now* followed by *No thanks, just take me to the download* and download the file called *0x72_DungeonTilesetII_v1.7.zip*


## Making the project
Set up a Basic 2D project, using the Forward+ Renderer. Let's start by importing our assets. 
First let's create a new folder, and call it something like 'Assets' 

Then, let's extract the assets from the folder we downloaded, and at them into our Assets folder. Mine looks like this, but it's fine if yours looks slightly different.

TODO: Image here 

![Godot new project window](/src/assets/godot/3DGameGuide/3dgameprojectsetup.png)

Let's also create two new top level folders called **Scripts** and **Scenes**

TODO: Image here


To ensure our pixel art assets look crisp and not blurred we'll want to make one quick change.

Using the buttons in the top left of the screen, select **Project -> Project settings** In this menu, select the **General** tab, and scroll until you see the **Rendering** header. Under this, select **Textures**

Change **Default Texture Filter** from **Linear** to **Nearest**

TODO: Settings image


## Creating the Player

Great! Let's start by making a basic version of our player character that will let us move around. We'll worry about more complicated things like attacking later.

Start by creating a new 2D Scene, with a **CharacterBody2D** as the root node. call it something like **Player**

Give the **CharacterBody2D** a name like **Player** and give it two children:

A **CollisionShape2D** and an **AnimatedSprite2D**

Here's how my scene looks with no other modifications:

TODO: Player scene basic img

Let's hit **Ctrl + S** and save this scene in our **Scenes** folder, call it something like **Player.tscn**

### Animations

Let's give ourselves something to look at! Click on the **AnimatedSprite2D** and in the inspector, under **Animation** you'll see **\<Empty>** in the **Spriteframes** field.
Click on **\<Empty>** and create a new **Spriteframes** Click on the **Spriteframes** you created. This will open a new window at the bottom of the screen.

This is where we'll create our player's animations. Rename the *General* animation to *Idle* and click the *Add frames from File* Button (The folder icon)

Navigate to your *assets/frames* folder, and decide which character you want to be your player. I'll be using the Plague Doctor. Using Shift + Click select all the frames for your character labeled *Idle* (This should be four frames) then open them.

TODO: Image

You'll see them added to the animation timeline. We'll want to select two things in the timeline. The **Loop** Button (To ensure the animation loops) and the **Play on start button** (To ensure the animation plays automatically)
Let's also increase the FPS to 8 so that the animation plays a little faster. 

Hit play to test! You'll see the player now has an idle animation that loops!

Let's add our characters walking animation. Add a new animation using the **Add animation** Button and call it something like "Walk"

TODO: add animation button image

Do the same thing we did to grab the frames for the idle animation, but this time, grab all the frames labeled "Run" it should again be 4 frames. We want this animation to loop, but we **don't** want it to autoplay. Let's also give this a framerate of 8 FPS.

TODO: Walk anim image

Finally, just select your idle animation again, to make sure this is what our player will start on.

great! That's our animations all done!

### Collision and Movement

Now that we have something to look at, let's give our player a hitbox. Open the inspector for the **CollisionShape2D** we added, and add a new shape in the **empty** shape field.
It's a good idea to use a **CapsuleShape** as it will make us less likely to get stuck on corners. Position and adjust the capsule so that it's *slightly* smalle than the sprite for our player.
Mine looks like this:

TODO: image CollisionShape2D

Great! Our player now has collision. We'll do one more thing while we're here, which is give our player a script to handle movement. Right click on the **CharacterBody2D** and Attach a script. Call it something like "player.gd" and make sure we're saving it 
in our Scripts folder. We also need to make sure we **untick** the **template** box as we will not be using the template! This is because the template is designed for gravity based platformers.

With our script created and attached, let's get to programming our movement!

First, let's set up a variable to control our speed.

```gdscript
@export var speed = 200
```

The **\@export** tag will allow us to easily edit our speed variable, without needing to open the script!

Then, we'll want to use Godots built in **_physics_process(delta):** function for our movement logic. Inside that we'll want to get the combined vector of all the inputs the player is pressing.

```gdscript
func _physics_process(delta):
    var direction = Input.get_vector("ui_left", "ui_right", "ui_up", "ui_down")
```

We'll then multiply this vector by our speed, and then invoke Godots built in **move_and_slide()** function

```gdscript
velocity = direction * speed

move_and_slide()
```

giving us a final script that looks like this:

```gdscript
extends CharacterBody2D

@export var speed = 200

func _physics_process(delta):
    var direction = Input.get_vector("ui_left", "ui_right", "ui_up", "ui_down")
    velocity = direction * speed

    move_and_slide()
```
For now our movement is controlled using the arrow keys, but we'll go over how to map it to whatever we want later in the guide.

Switch back to 2D view at the top of the screen.

## Building a level

Let's move onto giving us something to walk around. Create a new scene. Give it a node2D as its root node, and call it something like "World" 

Save the scene in our Scenes folder.

Give our root node a child node with the type **TileMap** this will handle the visuals and collision of our level. Call it something like "Level 1"
In the inspector, create a new **Tile Set** for the **empty** **Tile Set** field.

You'll notice two new tabs have appeared at the **TileSet** and **TileMap** we'll be working with both of these, but open the **TileSet** tab first.

using the **+** button in the lower left, navigate to your assets, and load in the "atlas_floor-16x16.png" hit **Yes** when prompted.

Do the same for the "atlas_walls_low-16x16.png" file, again hitting **Yes** when prompted.

You can think of these two as palettes we'll use to paint our levels! Our dungeon will be made up from a series of tiles that we can arrange however we want!

**Note: We won't be implementing the spikes/buttons/levers. So if you add these to your level they'll be purely decorative.**

Next, we'll want to make sure our walls appear **ontop** of our floors! To do this we'll use layers! On the right, in the inspector for the **TileMap** you'll see a section called layers, with one already there!

Call this one "Floors" and modify its **Z Index** field to be -1.

Click **Add Element** to add another layer. Call this one "Walls" and set its **Z Index** field to be 1.

Todo: layers image

With our **Tilesets** setup we can now go to the **TileMap** tab. 

From here, if you click on a tile and then in the scene, you'll notice your able to paint them into the scene! This is how we'll create our levels! you can click between the floor and wall tilesets to get access to the different tiles.

You'll also notice you can switch layers in the top righ of the **TileMap** section. Make sure you're in the right layer for what you're painting! Otherwise they won't appear right! It might be a good idea to do the floors first, followed by the walls.

Spend some time and get familiar with painting and removing tiles! Aim to create a single room that we can use to test our game.

**Tip: You can use the Rect tool to draw a rectangle of tiles all at once**

TODO: rect tool image

Here's what my room looks like:

TODO: Basic Room Image

### Adding our player to the level

Now that we have a basic level set up, let's add our player to it so we can start to properly test our game! To do this, we'll just drag our player scene from the **Scenes** folder
in the file browser, into our **scene tree** as a child of the root node! Finally, we'll give the player a child of type **Camera2D.** here's what my scene looks like:

[TODO: image]

You should be able to move around! Though you'll quickly notice you're able to walk through walls, which isn't ideal, so let's fix that!

### Level collision

Click on your **TileMap** Node again, select **TileSet** at the bottom of the screen, and click on your Wall **TileSet** Then, navigate to the inspector. Click the **TileSet** Object at the top of the inspector.
Under the **Physics Layers** drop down, click **Add Element.** 

Now, back in the section at the bottom of the screen, navigate to the **Paint** tab, and using the drop down, select **Physics Layer 0.** Here's how things look for me!

[TODO: Image]
Think of the blue square that has appeared under the **Paint** tab as our brush that we'll use to paint collisions onto our **Tileset** with the blue square representing where exactly our player will collide.


You can click and drag the white diamonds to move them, and click on the edges to add new points. pressing F (Full) will make the collider occupy the whole square, and pressing C (Clear) will make it occupy none of it.

So using this, try to create colliders for each tile that closely match their sprite. 

Tip: It'll be easiest to do them in batches of tiles that have the same collision!

Here's how mine look:

[TODO: Image]

Now try playing your game again! You'll notice you actually collide with the walls! Great!

## Improving our player

Let's spend some time further improving our player. Let's implement some different controls (Well be doing WASD, but you can using any controls you like)
make sure our animation changes to our walking animation when we move, and make sure our sprite faces in the direction we're moving.

We'll also be implementing attacking, but we'll do that in it's own section!

### Input mapping

To change our inputs, we'll first need to set up our **Input Map** to do this, we'll navigate to **Project -> Project Settings** in the top left of the workspace.

Then, open the **Input Map** tab.

We'll add our new Inputs by typing a name for each of them in the **Add New Action** box and hitting add. 

I'll be calling mine "Up" "Down" "Left" "Right" and i'll also add one called "Attack"

[TODO: Images]

To add buttons to these, we'll hit the "+" to the right of each action, we'll then physically press the key we want to assign on our keyboard, and hit "Ok"

For my **Attack** action i'll be using **Left Click* for which you'll want to physically click *once* inside the **Listening for input** box.

Here's what my inputs look like:
[TODO: Image]

If you're happy with your inputs, you can then hit **Close** at the bottom of the screen. Let's navigate back to our **player_movement.gd** script. This can be done by opening our **player** scene, clicking on the **CharacterBody2D** and clicking the **Script** tab at the top of the screen.

To change our inputs, all we need to do is change the predifined inputs to what we called ours!

**Note:** What you named your input actions *is* case sensitive

So, "ui_left" becomes "Left"
"ui_right" becomes "Right" and so on!

leaving that line line in our script looking like this:

```gdscript
    var direction = Input.get_vector("Left", "Right", "Up", "Down")
```
if you run your game, you'll notice your inputs are now changed!

We won't assign our Attack option just yet, but it's good we've created it already.

### Animation switching

To change our animation depending on if we're moving or not, we'll only need to add a few lines to our script. But first, we'll need a reference to our **AnimatedSprite2D** in our script.

We can do this easily, by **Clicking** and **Dragging** our **AnimatedSprite2D** into our script, making sure we hold **Ctrl** on the keyboard after grabbing it, but before dropping it.

We'll want to drop it below 

```gdscript
@export var speed = 200
```
It should get added to our script looking like:

```gdscript
@onready var animated_sprite_2d = $AnimatedSprite2D
```

if it doesn't look like this, delete the line and try again, making sure you're holding **Ctrl** on your keyboard after picking it up.

Great! Let's get to changing our animation!

Under where we set our velocity, we'll simply add a check to see if our velocity is anything other than 0 and change our animation based on that!

We can check this simply with:

**Note:** Why can't we just do velocity != 0? This is because velocity actually contains both our X (Horizontal) and Y (Vertical) velocity, so we need to make sure **Both** aren't zero.

```gdscript
if velocity != Vector2.ZERO:
```

Then, we can play our run animation!

```gdscript
if velocity != Vector2.ZERO:
    animated_sprite_2d.play("walk")
```

and if we're not moving, let's play our idle

```gdscript
else:
	animated_sprite_2d.play("idle")
```

Giving us a movement script that looks like this:

```gdscript
extends CharacterBody2D

@export var speed = 200
@onready var animated_sprite_2d = $AnimatedSprite2D

func _physics_process(delta):
	var direction = Input.get_vector("Left", "Right", "Up", "Down")
	velocity = direction * speed
	if velocity != Vector2.ZERO:
		animated_sprite_2d.play("walk")
	else:
		animated_sprite_2d.play("idle")

	move_and_slide()
```

Play your game, and you'll notice your animation changes when you move!

### Sprite facing

To flip our player based on the direction we're moving, all we really need to do is add another If to check only the **Horizontal** part of our velocity, as thankfully the **AnimatedSprite2D** node has a built in way to flip our sprite!

I'll be adding this section **beneath** the animation section, but before the **move_and_slide()** function call.

let's start by checking the Horizontal portion of our movement:

```gdscript
if(velocity.x < 0):
```
if our x velocity is less than 0 (moving to the left) we want to flip our sprite.

```gdscript
animated_sprite_2d.flip_h = true
```

And if it's greater than 0, we'll unflip it

```gdscript
elif(velocity.x > 0):
		animated_sprite_2d.flip_h = false
```

giving us a movement script that looks like this:

```gdscript
extends CharacterBody2D

@export var speed = 200
@onready var animated_sprite_2d = $AnimatedSprite2D

func _physics_process(delta):
	var direction = Input.get_vector("Left", "Right", "Up", "Down")
	velocity = direction * speed 
	
	if velocity != Vector2.ZERO:
		animated_sprite_2d.play("walk")
	else:
		animated_sprite_2d.play("idle")
		
	if(velocity.x < 0):
		animated_sprite_2d.flip_h = true
	elif(velocity.x > 0):
		animated_sprite_2d.flip_h = false

	move_and_slide()
```
**Note:** Why didn't we juse use **else:**? - If we'd just used **Else:** our sprite would have jarringly flipped to face left whenever we stopped moving, or if we were just moving up and down. 
This way the direction our sprite is facing doesn't change unless we move either left or right!

Test your game, and you'll notice your sprite now faces left or right depending on the direction we're facing!

## The Weapon

### Weapon Scene

Let's create a new scene for our weapon!
Give it a root node of just a **Node2D** with two children, a **Sprite2D** and a **Animationplayer** 
Give the sprite a child of type **Area2D** and give the **Area2D** a child of **CollisionShape2D**

Name the root **Node2D** something like "Weapon" 

Here's how my scenetree looks:

[TODO: Weapon scenetree]

Make sure you save the scene, calling it something like "Weapon.tscn"

Let's start by picking a sprite for our weapon, so we can see what we're working with!
Select the sprite node, and in the **Empty** texture field, select Load. Navigate to your assets folder, and select a weapon that you like!

Don't worry that it's pointing up, we'll rotate it in a minute.

Let's open the **CollisionShape2D** node and assign a shape, you'll probably just want to use a rectangle shape. This will be the hitbox of the sword, and determine whether an enemy has been hit! Adjust its bounds so that it vaguely matches the sprite. 
Although you'll likely want to make it a little bigger than the sprite, as we don't want our game to feel like the player has to be too precise.

let's rotate the **Sprite2D** node. Do this by selecting the node in the scenetree, navigating to the inspector, opening the **Transform** tab and changing the rotation to **90**

Let's also offset it's position a little, to help it rotate around our player smoothly. Set its x-position to something like **20px**

Here's how my sword scene and inspector look: 

[TODO: swordSceneInspector]

### Weapon Script

Let's create a script to control our weapon, create it using the default template and attach it to the **root node2d,** call it something like "weapon"

We'll need this script to do two things:

1. Rotate around our player, facing the mouse.
2. Play the animation when we press our attack input.

The first step will be nice and easy! In the **process** function, add the line
```gdscript
look_at(get_global_mouse_position())
```
This will cause this node to always face toward the position of the mouse!

Next, we'll need to get a reference to our **AnimatedSprite2D** node, we'll do this the same way we did for the **animated_sprite_2d** node for the player' by clicking, dragging, and then holding ctrl before we let go of the click.

We'll also want a variable that keeps track of if we're *currently* attacking, as we don't want the sword to destroy enemies when we haven't attacked.

your script should look like this:

```gdscript
extends Node2D

@onready var animation_player = $AnimationPlayer
@export var attacking : bool = false

func _process(delta):
	look_at(get_global_mouse_position())
```

Great, now let's add a check to see if we've just used the **Attack** input action we created earler, and play the animation we'll create next. This is all stuff we've done earlier, so this should be pretty easy. Here's what it'll look like!

Making sure that the Input action name, and animation name match, including case sensitivity. 
```gdscript
extends Node2D

@onready var animation_player = $AnimationPlayer

@export var attacking : bool = false

func _process(delta):
	look_at(get_global_mouse_position())
	
	if Input.is_action_just_pressed("Attack"):
		animation_player.play("Attack")

```

### Sword Animation

Now, let's starting creating our attack animation! Navigate to the **Animationplayer** and click **Animation** and create a new animation. Call it "Attack"
Now that we've created a new animation, we'll need to create an **Animation Track** which you can do by clicking **Add track.** This will ask us what type of Animation Track we want to create.

We want to animation the **Position** of our weapon, this is a **Property** so we'll create a **Property** Track. 

Then, when prompted, we'll select the **Sprite2D** as this is what we want to change the position of!

Finally, scroll until you see the **Position** property. 

Phew! That was quite a few steps, but our animation track is created!

Great, now we need to determine the keyframes our sword will animate between. We'll need three: The first being the start position, the second being the extent of the attack, and the third being returning to the start position.

To add a keyframe, right click on the animation track. (In the **Position** Row) and press **Insert Key** do this until you have three keyframes. If we select each keyframe, we can modify their values!

The first and last keyframe, we want to be at **Time** 0 and 1.0 respectively, with their values being unchanged (Remember, we want both of these to represent the sword at rest)

Our second keyframe, we'll for now put at a **Time** of 0.5. Let's however, set its **x-value** to 30.

Great! Let's hit the play button on the animation, and you'll notice we have a simple stabbing animation. But it's a little slow... We can fix this by adjusting the total length of the animation, this can be done over on the right. 

Change the length from 1.0 to 0.5. We'll then need to adjust our keyframes, adjusting the middle one to be at a **Time** of 0.25, and the last to be at 0.5.

Play it again, and you'll notice it's much faster!

We'll want to add another **Property Animation Track** this time to modify the **attacking** variable, to keep track of if our weapon is "Active" or not.

Add a new animation track, select property, and you should see "attacking" right at the top! Add two keyframes, one right at the start, and one right at the end. The first we'll want to set the value to "on" (as we're now attacking) and the one at the end will set the property back to "off" (or unticked)

And that's it! We'll come back later to add the code for destroying enemies.

Great! Let's get our weapon added to our player!

### Adding our weapon to our player

Navigate to your player secene. From the filesystem, drag in your weapon scene (Likely called something like **weapon.tscn**) and attach it as a child of the main 
**CharacterBody2D** node. 

Play your game, and you should hopefully have a weapon that rotates around the player and stabs when you click it! If it doesn't seem to be rotating around the middle of the player sprite, feel free to adjust its position within the Player scene.

You're also welcome to adjust the size of the weapon (Although, you're best to do this within the weapon scene itself) it's your game after all!

## Health

### Player Health

Let's start setting up our health system on the player side, we'll start by adding a new Node to our player, as a child of the root **CharacterBody2D** node. The node should be of type **Area2D** 
give the **Area2D** a child of type **CollisionShape2D** rename the Area2D to something like "Hitbox." 

In the **Inspector** of the **Area2D** Navigate to the **Collision** section. Deselect all numbers under the **Layer** Section, and ensure *only* 2 is selected under the **Mask** Section.

Give the **CollisionShape2D** a shape, ideally a rectangle or circle, and make it *slightly* bigger than the shape for the **CharacterBody2D's** **CollisionShape2D**

Let's give the **Area2D** one more child of type **Timer** and name it something like "damageTimer" this timer will be used to determine how quickly we can take damage again after being hurt, think of it as invulnerability time!
In the timer's inspector, set its **Wait Time** field to 0.5s

Great! this **Area2D** will be used to detect collision with enemies, potions, and coins! For now we'll just be setting it up to handle health, both healing and damage.

Let's attach a script to the **Area2D** (that we named "Hitbox") and call it something like "hitbox.gd"

This script is going to get a little complicated, as it's going to have to handle quite a few things. In a bigger project we would want to break its funcitonality up into multiple scripts, but for our scope this is fine!
Let's break down what we need it to do:

1. Track our health
2. Detect collisions with potions/enemies/coins
3. Change our health value
4. Update the UI

Let's start by creating the variables we'll need, those being:

1. The signal we'll use to talk to the UI when our health has changed
2. While we're here, a signal for when we've collected a coin, as it'll also talk to the UI
3. A max health, and current health value
4. A reference to the timer we created.
5. A boolean determining if we can take damage

These should look something like this, using the same click + drag + ctrl method to get the reference to the **Timer**

```gdscript
signal on_health_changed(new_health : int)
signal on_point_gained
@export var max_health : int = 6
@onready var damage_timer = $damageTimer
var health : int
var can_take_damage : bool = true
```

**Remember:** We can use the **\@export** to modify the max health value, without editing the script!

**Note:** Why are we starting at 6 health? We're doing this because each point of health will represent half a heart to the UI, for a total of 3 full hearts! Using ints like this is safer than using a float,
because what if we somehow end up with 0.001 health!

in our **_ready** function we'll want to set some default values, and emit the health_changed signal to send our starting health to the UI.

```gdscript
func _ready():
	health = max_health
	emit_signal("on_health_changed", health)
```

Right, let's get onto the most complicated function in the script, the function for taking damage! In this function, there'll be a few different possible outcomes.
1. We can't take damage as we're currently immune. In this case. Nothing happens
2. Otherwise we'll take damage. Emitting the signal to change the UI.
3. If we do take damage, we might be reduced to 0 hitpoints
4. If we are, we die! If we're not. We start our immunity timer.

Great! Let's write that in gdscript:

```gdscript
func take_damage():
	if can_take_damage:
		health = health - 1
		emit_signal("on_health_changed", health)
		
		if health <= 0:
			print("you died!")
		else:
			can_take_damage = false
			damage_timer.connect("timeout", allow_damage())
			damage_timer.start()
```

**Note:** For now we'll just having dying print to the console and do nothing else, as we'll want some proper UI.

You'll notice we connected our timer to a function called **allow_damage()** which doesn't exist, let's create that now. All it's going to do is set the **can_take_damage** boolean to **True** as unfortunately Godot doesn't let you assign a value to a variable directly via the **connect()** function.

```gdscript
func allow_damage():
	can_take_damage = true
```

Next we'll do healing! This one is *much* easier. We just need to check if we have room to be healed (Our health is less than our max health). If we do, increase our health by 1. Then emit the signal to update the UI! We'll also want to delete the potion, so it can no longer be used.

```gdscript
func heal(body):
	if health < max_health:
		health = health + 1
		emit_signal("on_health_changed", health)
		body.queue_free()
```

Finally, we need a function that calls our **heal** and **damage** functions based on what we've collided with. To check what type of object we've collided with, we'll be using **Groups!** These are something we'll assign to our enemies/potions/coins later.

To check if something has collided with us, we'll need to the **on_body_entered** signal! To connect this, swap to the **Node** tab of the **Inspector** and click on the **Area2D** node in the **SceneTree** again. You'll see a list of all the signals we have available to us!
Click the **on_body_entered** signal and press **Connect** select the **Area2D (hitbox)** node and click **Connect** 

You'll see a new function appear in our script! On that'll be called whenever something enteres this **Area2D**

In here, we can check the **Group** of what we've collided with! Let's also add a check to see if we've collected a coin here, to save us some time later!

```gdscript
func _on_body_entered(body):
	if body.is_in_group("enemy"):
		take_damage()
	elif body.is_in_group("health"):
		heal(body)
	elif body.is_in_group("coin"):
		emit_signal("on_point_gained")
		body.queue_free()

```
and that's it! Giving us a full script that looks something that this:

```gdscript
extends Area2D

signal on_health_changed(new_health : int)
signal on_point_gained
@export var max_health : int = 6
@onready var damage_timer = $damageTimer
var health : int
var can_take_damage : bool = true

# Called when the node enters the scene tree for the first time.
func _ready():
	health = max_health
	emit_signal("on_health_changed", health)

func _on_body_entered():
	if body.is_in_group("enemy"):
		take_damage()
	elif body.is_in_group("health"):
		heal(body)
	elif body.is_in_group("coin"):
		emit_signal("on_point_gained")
		body.queue_free()
		

func take_damage():
	if can_take_damage:
		health = health - 1
		emit_signal("on_health_changed", health)
		
		if health <= 0:
			print("you died!")
		else:
			can_take_damage = false
			damage_timer.connect("timeout", allow_damage())
			damage_timer.start()
	
func heal(body):
	if health < max_health:
		health = health + 1
		emit_signal("on_health_changed", health)
		body.queue_free()
	
func allow_damage():
	can_take_damage = true
```

**Note:** If you copy and paste the above, you'll still need to manually connect the **on_body_entered** signal!

And that's the player side of health done! Let's move onto the UI side!

### Health UI

Time to start making some UI! Let's make a new scene, of, as you may have guessed, type **User Interface.** call the Root node something like "UI" and add a child of type **HBoxContainer** This is a UI element that will neatly arrange our UI elements, in this case our hearts, horizontally!

Let's open its inspector, navigate to the **Layout** tab and change it to "Anchors." Then change the **Anchor Preset** to "top left." This will make sure that whetever the size of our screen is, the health will always be pinned to the top left!

Rename the node to something like "healthContainer." When we add hearts, this will be their parent Node, controlling their position on the screen and in relation to one another. (Like making sure they don't overlap)

 Great! That's all the UI setup we'll need to do for now (Though we'll come back to it later for points, and a "You died" message)

 Add a script to the root node, calling it something like "ui.gd"

 Let's think about what we need this script to do: 
 1. Store our three different heart images
 2. Recieve signals from our player when we take damage
 3. Update our health UI.

 We'll set this up so that it automatically adjusts depending on the players **max_health** when the game is run, so you can easily have more (or less) than three hearts! 
 (Or, you could implement an item that increases your max hp!)

 Thankfull, we can reference images in our filesystem the same way we can reference nodes, with the **Drag + Ctrl + Release** technique we've been using! We'll want: The full heart image, the half heart image, and the empty heart image

Find these in yor filesystem, and drag in the references, it should look something like this: 

```gdscript
const UI_HEART_EMPTY = preload("res://Assets/frames/ui_heart_empty.png")
const UI_HEART_FULL = preload("res://Assets/frames/ui_heart_full.png")
const UI_HEART_HALF = preload("res://Assets/frames/ui_heart_half.png")
```

Let's also get a reference to our **healthContainer** node, and create a variable to keep track of the most health we've had so far (This lets us know how many empty hearts to have!)
We won't set this variable here, as it'll be set by whatever the most health we've had so far has been.

```gdscript
@onready var health_cont = $healthContainer
var maxHealth : int = 0
```
Next will be the function that our signal will call, where most of the logic will happen, so let's think about what we need it to do!

1. If the health recieved is bigger than our highest health so far, make that our new highest health. Easy enough!

```gdscript
func changed_health(newHealth : int):
	if newHealth > maxHealth:
		maxHealth = newHealth
```

2. we'll want to check if we have enough hearts currently to represent that, if we don't, we'll need to add some more. (We'll create the function for this last)

```gdscript
	if(maxHealth/2 > health_cont.get_child_count()):
		for h in (maxHealth/2) - health_cont.get_child_count():
			add_heart()
```

3. we'll iterate through all the children our **healthContainer** node has, and assign an image based on the current health.

This section may look complicated, but once you get your head around it, it's fairly simple! Spend some time looking over it, and thinking about the conditions for each heart to be drawn.
When I was figuring out how to program this, I found it useful to draw out the hearts on paper, at different levels of health!

```gdscript
for i in health_cont.get_child_count():
		if (i * 2) + 1 < newHealth:
			health_cont.get_child(i).texture = UI_HEART_FULL
		elif (i * 2) < newHealth:
			health_cont.get_child(i).texture = UI_HEART_HALF
		else:
			health_cont.get_child(i).texture = UI_HEART_EMPTY
```

giving us a full **changed_health** function that looks like this:

```gdscript
func changed_health(newHealth : int):
	if newHealth > maxHealth:
		maxHealth = newHealth
		
	if(maxHealth/2 > health_cont.get_child_count()):
		for h in (maxHealth/2) - health_cont.get_child_count():
			add_heart()
	
	for i in health_cont.get_child_count():
		if (i * 2) + 1 < newHealth:
			health_cont.get_child(i).texture = UI_HEART_FULL
		elif (i * 2) < newHealth:
			health_cont.get_child(i).texture = UI_HEART_HALF
		else:
			health_cont.get_child(i).texture = UI_HEART_EMPTY
```

Not too bad!

Let's add that **add_heart** function, which just creates and configures another child if we need one.

```gdscript
func add_heart():
	var img : TextureRect = TextureRect.new()
	img.expand_mode = TextureRect.EXPAND_FIT_WIDTH
	health_cont.add_child(img)
```

Let's also while we're here, add an empty function for our point system, which we'll come back to later!

```gdscript
func add_point():
	pass
```

Save the scene as something like "UI.tscn"

Go back to your main level scene. Add a new child of type **CanvasLayer** and add your new UI scene as a child of this! (This ensures that that the UI 'sticks' to the camera, rather than existing within the game)

*Finally,* to get everything hooked up, we just need to connect that signal! Open up **hitbox.gd**

First, we'll get a reference to our new **UI** scene. Put this with the other variable declarations.

```gdscript
@onready var ui : Control = $"../../CanvasLayer/UI"
```

Then, finally, before we call the signal the first time, connect the signal with:

```gdscript
on_health_changed.connect(ui.changed_health)
```
we'll also connect our point signal with:

```gdscript
on_point_gained.connect(ui.add_point)
```

Run your game! And you should have 3 hearts! Great!

## Pickups

Let's get onto pickups! Our game will have two types of pickups: Coins, and Potions. Coins will give us a point, and Potions will heal us for half a heart!

Thankfully the setup for the two will be extremely simple, and they won't even need a script! As all logic is handled by our hitbox script!

### Coins

For coins, we'll create a new scene with a root node of **Staticbody2D** calling it something like "Coin"

It should have a child of type **CollisionShape2D**

We'll also want to add an **AnimatedSprite2D** to the root node.

Here's how my scene looks:

[TODO: coin scene]

We'll add the animation the same way we did with our player! Click on the **AnimatedSprite2D** and in the inspector, under **Animation** create a new **Spriteframes**

Click on the new **Spriteframes** and add sprites from file. (The coin has four frames) Make sure to click **autoplay** (The 'A' in the pointy box)
and then assign a shape to the **CollisionShape2D** that loosely matches the coin. (I just used a circle)

The coin as is is very small, so open the inspector for the root **Staticbody2D** and change the **Scale** values to 2.

Now, all that's left to do is create a **Group.** With the root **Staticbody2D** still selected, navigate to the **Node** tab of the inspector, then to the **Groups** tab.

[TODO: Groups img]

In the box, type "coin" and click **Add**

Then, click **Manage Groups** and select each Node, followed by **Add** to ensure that each node in the scene is in the group.

Finally, we'll want to open the **Collision** tab on the inspector of the **Staticbody2D** setting the **Layer** to *only* 2, and deselecting all numbers under the **Mask** as we don't want our coin to be looking for collisions, or to be physically collided with!

And that's our coin! The only script work we need to do is in our **UI** script! But first we'll need to add a UI element to track our points!

Don't worry, we've done all the hard work of connecting signals earlier! This'll be nice and easy!

Let's head to our UI Scene. To the root node, add a new child, of type **HBoxContainer** call it something like "pointContainer"

Give it two children, a **TextureRect** and a **Label,** name the label something like **pointsLabel** 

In the inspector of the **TextureRect** set the **Expand Mode** to "Fit Width" and assign the first coin image to the **Texture** field using the **Load** Option

Finally for UI setup, in the inspector of the **Label** write "0" in the **Text** field. You'll notice this is pretty small! Scroll down in the **Inspector** until you see **Theme Overrides.** in this section you'll find **Font Sizes.** Set this to something you think looks good! I went with 40px.

Great! Now we just need to add two lines of code to our UI. and then our points are done!

First, a reference to our label, same way we've been doing, this should be second nature by now!

```gdscript
@onready var points_label = $pointContainer/pointsLabel
```

then, we'll finish the function we created earlier.


```gdscript
func add_point():
	points_label.text = str(int(points_label.text) + 1)
```
This looks a little silly, but what we're doing is taking the current text in the label, converting it to a number, adding 1 to it, and then converting to *back* to a string.

If you've set it all up right, you should notice this number going up each time you pick up a coin! Add a few instances of the coin scene to your level to test!

### Potions

For potions the process is exactly the same! You should be able to do it on your own! Just follow the steps for creating the coin scene. Except in this case we'll just want a regular **Sprite2D** As the potion sprite isn't animated, and we'll want the group to be called "health" (make sure it matches the line we wrote in **hitbox.gd**)

## Enemies

### Enemy Scene

### Enemy Scripting

## Another floor

## Finishing up!


TODO: Link to docs
TODO: general cleanup pass
TODO: Add images
TODO: Weapon active logic
TODO: destroying coins and potions





