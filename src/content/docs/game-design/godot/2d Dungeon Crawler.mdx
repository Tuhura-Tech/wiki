---
title: Making a 2D top down dungeon crawler
description: This page works through 2D top down dungeon crawler step-by-step
sidebar:
    order: 5
---


This is a guide to making a 2-dimensional dungeon crawling game in [Godot](https://godotengine.org/). If you are unfamiliar with Godot, check out the [Godot basics](/game-design/godot/basics) doc as this tutorial assumes basic knowledge of navigating and using the Godot Engine.

:::note[Version]
This guide is up-to-date with Godot 4.2 stable official release but will most likely work with any 4.x release.
:::

We'll be making a game in which the player explores a multi-floor dungeon in a top-down perspective. This project will include:
- Movement 
- Attacking
- Health loss & Gain 
- Pickups (Coins & Potions)
- Enemies

We will not be creating our own assets as part of this project, although you are of course welcome to!

We'll instead be using a free asset pack by Ox72 on Itch.IO which [can be found here](https://0x72.itch.io/dungeontileset-ii) Just click *Download now* followed by *No thanks, just take me to the download* and download the file called *0x72_DungeonTilesetII_v1.7.zip*


## Making the project
Set up a Basic 2D project, using the Forward+ Renderer. Let's start by importing our assets. 
First let's create a new folder, and call it something like 'Assets' 

Then, let's extract the assets from the folder we downloaded, and at them into our Assets folder. Mine looks like this, but it's fine if yours looks slightly different.

TODO: Image here

![Godot new project window](/src/assets/godot/3DGameGuide/3dgameprojectsetup.png)

Let's also create two new top level folders called **Scripts** and **Scenes**

TODO: Image here


To ensure our pixel art assets look crisp and not blurred we'll want to make one quick change.

Using the buttons in the top left of the screen, select **Project -> Project settings** In this menu, select the **General** tab, and scroll until you see the **Rendering** header. Under this, select **Textures**

Change **Default Texture Filter** from **Linear** to **Nearest**

TODO: Settings image


## Creating the Player

Great! Let's start by making a basic version of our player character that will let us move around. We'll worry about more complicated things like attacking later.

Start by creating a new 2D Scene, with a **CharacterBody2D** as the root node.

Give the **CharacterBody2D** a name like **Player** and give it two children:

A **CollisionShape2D** and an **AnimatedSprite2D**

Here's how my scene looks with no other modifications:

TODO: Player scene basic img

Let's hit **Ctrl + S** and save this scene in our **Scenes** folder, call it something like **Player.tscn**

### Animations

Let's give ourselves something to look at! Click on the **AnimatedSprite2D** and in the inspector, under **Animation** you'll see **\<Empty>** in the **Spriteframes** field.
Click on **\<Empty>** and create a new **Spriteframes** Click on the **Spriteframes** you created. This will open a new window at the bottom of the screen.

This is where we'll create our player's animations. Rename the *General* animation to *Idle* and click the *Add frames from File* Button (The folder icon)

Navigate to your *assets/frames* folder, and decide which character you want to be your player. I'll be using the Plague Doctor. Using Shift + Click select all the frames for your character labeled *Idle* (This should be four frames) then open them.

TODO: Image

You'll see them added to the animation timeline. We'll want to select two things in the timeline. The **Loop** Button (To ensure the animation loops) and the **Play on start button** (To ensure the animation plays automatically)
Let's also increase the FPS to 8 so that the animation plays a little faster. 

Hit play to test! You'll see the player now has an idle animation that loops!

Let's add our characters walking animation. Add a new animation using the **Add animation** Button and call it something like "Walk"

TODO: add animation button image

Do the same thing we did to grab the frames for the idle animation, but this time, grab all the frames labeled "Run" it should again be 4 frames. We want this animation to loop, but we **don't** want it to autoplay. Let's also give this a framerate of 8 FPS.

TODO: Walk anim image

Finally, just select your idle animation again, to make sure this is what our player will start on.

great! That's our animations all done!

### Collision and Movement

Now that we have something to look at, let's give our player a hitbox. Open the inspector for the **CollisionShape2D** we added, and add a new shape in the **empty** shape field.
It's a good idea to use a **CapsuleShape** as it will make us less likely to get stuck on corners. Position and adjust the capsule so that it's *slightly* smalle than the sprite for our player.
Mine looks like this:

TODO: image CollisionShape2D

Great! Our player now has collision. We'll do one more thing while we're here, which is give our player a script to handle movement. Right click on the **CharacterBody2D** and Attach a script. Call it something like "player_movement" and make sure we're saving it 
in our Scripts folder. We also need to make sure we **untick** the **template** box as we will not be using the template! This is because the template is designed for gravity based platformers.

With our script created and attached, let's get to programming our movement!

First, let's set up a variable to control our speed.

```gdscript
@export var speed = 200
```

The **\@export** tag will allow us to easily edit our speed variable, without needing to open the script!

Then, we'll want to use Godots built in **_physics_process(delta):** function for our movement logic. Inside that we'll want to get the combined vector of all the inputs the player is pressing.

```gdscript
func _physics_process(delta):
    var direction = Input.get_vector("ui_left", "ui_right", "ui_up", "ui_down")
```

We'll then multiply this vector by our speed, and then invoke Godots built in **move_and_slide()** function

```gdscript
velocity = direction * speed

move_and_slide()
```

giving us a final script that looks like this:

```gdscript
extends CharacterBody2D

@export var speed = 200

func _physics_process(delta):
    var direction = Input.get_vector("ui_left", "ui_right", "ui_up", "ui_down")
    velocity = direction * speed

    move_and_slide()
```
For now our movement is controlled using the arrow keys, but we'll go over how to map it to whatever we want later in the guide.

Switch back to 2D view at the top of the screen.

## Building a level

Let's move onto giving us something to walk around. Create a new scene. Give it a node2D as its root node, and call it something like "Floor 1" 

Save the scene in our Scenes folder.

Give our root node a child node with the type **TileMap** this will handle the visuals and collision of our level.
In the inspector, create a new **Tile Set** for the **empty** **Tile Set** field.

You'll notice two new tabs have appeared at the **TileSet** and **TileMap** we'll be working with both of these, but open the **TileSet** tab first.

using the **+** button in the lower left, navigate to your assets, and load in the "atlas_floor-16x16.png" hit **Yes** when prompted.

Do the same for the "atlas_walls_low-16x16.png" file, again hitting **Yes** when prompted.

You can think of these two as palettes we'll use to paint our levels! Our dungeon will be made up from a series of tiles that we can arrange however we want!

**Note: We won't be implementing the spikes/buttons/levers. So if you add these to your level they'll be purely decorative.**

Next, we'll want to make sure our walls appear **ontop** of our floors! To do this we'll use layers! On the right, in the inspector for the **TileMap** you'll see a section called layers, with one already there!

Call this one "Floors" and modify its **Z Index** field to be -1.

Click **Add Element** to add another layer. Call this one "Walls" and set its **Z Index** field to be 1.

Todo: layers image

With our **Tilesets** setup we can now go to the **TileMap** tab. 

From here, if you click on a tile and then in the scene, you'll notice your able to paint them into the scene! This is how we'll create our levels! you can click between the floor and wall tilesets to get access to the different tiles.

You'll also notice you can switch layers in the top righ of the **TileMap** section. Make sure you're in the right layer for what you're painting! Otherwise they won't appear right! It might be a good idea to do the floors first, followed by the walls.

Spend some time and get familiar with painting and removing tiles! Aim to create a single room that we can use to test our game.

**Tip: You can use the Rect tool to draw a rectangle of tiles all at once**

TODO: rect tool image

Here's what my room looks like:

TODO: Basic Room Image

## Adding our player to the level

Now that we have a basic level set up, let's add our player to it so we can start to properly test our game! To do this, we'll just drag our player scene from the **Scenes** folder
in the file browser, into our **scene tree** as a child of the root node! Finally, we'll give the player a child of type **Camera2D.** here's what my scene looks like:

[TODO: image]

You should be able to move around! Though you'll quickly notice you're able to walk through walls, which isn't ideal, so let's fix that!

### Level collision

Click on your **TileMap** Node again, select **TileSet** at the bottom of the screen, and click on your Wall **TileSet** Then, navigate to the inspector. Click the **TileSet** Object at the top of the inspector.
Under the **Physics Layers** drop down, click **Add Element.** 

Now, back in the section at the bottom of the screen, navigate to the **Paint** tab, and using the drop down, select **Physics Layer 0.** Here's how things look for me!

[TODO: Image]
Think of the blue square that has appeared under the **Paint** tab as our brush that we'll use to paint collisions onto our **Tileset** with the blue square representing where exactly our player will collide.


You can click and drag the white diamonds to move them, and click on the edges to add new points. pressing F (Full) will make the collider occupy the whole square, and pressing C (Clear) will make it occupy none of it.

So using this, try to create colliders for each tile that closely match their sprite. 

Tip: It'll be easiest to do them in batches of tiles that have the same collision!

Here's how mine look:

[TODO: Image]

Now try playing your game again! You'll notice you actually collide with the walls! Great!

## Improving our player

Let's spend some time further improving our player. Let's implement some different controls (Well be doing WASD, but you can using any controls you like)
make sure our animation changes to our walking animation when we move, and make sure our sprite faces in the direction we're moving.

We'll also be implementing attacking, but we'll do that in it's own section!

### Input mapping

To change our inputs, we'll first need to set up our **Input Map** to do this, we'll navigate to **Project -> Project Settings** in the top left of the workspace.

Then, open the **Input Map** tab.

We'll add our new Inputs by typing a name for each of them in the **Add New Action** box and hitting add. 

I'll be calling mine "Up" "Down" "Left" "Right" and i'll also add one called "Attack"

[TODO: Images]

To add buttons to these, we'll hit the "+" to the right of each action, we'll then physically press the key we want to assign on our keyboard, and hit "Ok"

For my **Attack** action i'll be using **Left Click* for which you'll want to physically click (once) inside the **Listening for input** box.

Here's what my inputs look like:
[TODO: Image]

If you're happy with your inputs, you can then hit **Close** at the bottom of the screen. Let's navigate back to our **player_movement.gd** script. This can be done by opening our **player** scene, clicking on the **CharacterBody2D** and clicking the **Script** tab at the top of the screen.

To change our inputs, all we need to do is change the predifined inputs to what we called ours!

**Note:** What you named your input actions *is* case sensitive

So, "ui_left" becomes "Left"
"ui_right" becomes "Right" and so on!

leaving that line line in our script looking like this:

```gdscript
    var direction = Input.get_vector("Left", "Right", "Up", "Down")
```
if you run your game, you'll notice your inputs are now changed!

We won't assign our Attack option just yet, but it's good we've created it already.

### Animation switching

To change our animation depending on if we're moving or not, we'll only need to add a few lines to our script. But first, we'll need a reference to our **AnimatedSprite2D** in our script.

We can do this easily, by **Clicking** and **Dragging** our **AnimatedSprite2D** into our script, making sure we hold **Ctrl** on the keyboard after grabbing it, but before dropping it.

We'll want to drop it below 

```gdscript
@export var speed = 200
```
It should get added to our script looking like:

```gdscript
@onready var animated_sprite_2d = $AnimatedSprite2D
```

if it doesn't look like this, delete the line and try again, making sure you're holding **Ctrl** on your keyboard after picking it up.

Great! Let's get to changing our animation!

Under where we set our velocity, we'll simply add a check to see if our velocity is anything other than 0 and change our animation based on that!

We can check this simply with:

**Note:** Why can't we just do velocity != 0? This is because velocity actually contains both our X (Horizontal) and Y (Vertical) velocity, so we need to make sure **Both** aren't zero.

```gdscript
if velocity != Vector2.ZERO:
```

Then, we can play our run animation!

```gdscript
if velocity != Vector2.ZERO:
    animated_sprite_2d.play("walk")
```

and if we're not moving, let's play our idle

```gdscript
else:
	animated_sprite_2d.play("idle")
```

Giving us a movement script that looks like this:

```gdscript
extends CharacterBody2D

@export var speed = 200
@onready var animated_sprite_2d = $AnimatedSprite2D

func _physics_process(delta):
	var direction = Input.get_vector("Left", "Right", "Up", "Down")
	velocity = direction * speed
	if velocity != Vector2.ZERO:
		animated_sprite_2d.play("walk")
	else:
		animated_sprite_2d.play("idle")

	move_and_slide()
```

Play your game, and you'll notice your animation changes when you move!

### Sprite facing

To flip our player based on the direction we're moving, all we really need to do is add another If to check only the **Horizontal** part of our velocity, as thankfully the **AnimatedSprite2D** node has a built in way to flip our sprite!

I'll be adding this section **beneath** the animation section, but before the **move_and_slide()** function call.

let's start by checking the Horizontal portion of our movement:

```gdscript
if(velocity.x < 0):
```
if our x velocity is less than 0 (moving to the left) we want to flip our sprite.

```gdscript
animated_sprite_2d.flip_h = true
```

And if it's greater than 0, we'll unflip it

```gdscript
elif(velocity.x > 0):
		animated_sprite_2d.flip_h = false
```

giving us a movement script that looks like this:

```gdscript
extends CharacterBody2D

@export var speed = 200
@onready var animated_sprite_2d = $AnimatedSprite2D

func _physics_process(delta):
	var direction = Input.get_vector("Left", "Right", "Up", "Down")
	velocity = direction * speed 
	
	if velocity != Vector2.ZERO:
		animated_sprite_2d.play("walk")
	else:
		animated_sprite_2d.play("idle")
		
	if(velocity.x < 0):
		animated_sprite_2d.flip_h = true
	elif(velocity.x > 0):
		animated_sprite_2d.flip_h = false

	move_and_slide()
```
**Note:** Why didn't we juse use **else:**? - If we'd just used **Else:** our sprite would have jarringly flipped to face left whenever we stopped moving, or if we were just moving up and down. 
This way the direction our sprite is facing doesn't change unless we move either left or right!

Test your game, and you'll notice your sprite now faces left or right depending on the direction we're facing!

## Attacking

### Weapon Scene

### Adding our weapon to our player

## Health

## Pickups

### Coins

### Potions

## Enemies

## Another floor


TODO: Link to docs
TODO: general cleanup pass
TODO: Add images





