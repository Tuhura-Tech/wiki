---
title: Defend the Crystal
description: This page works through creating a full 3D game step by step
sidebar:
    order: 5
---

This is a guide for making a 3-dimensional game in [Godot](https://godotengine.org/). If you are unfamiliar with Godot, check out the [Godot basics](/game-design/godot/basics) doc and the [3D fundmentals](/game-design/godot/3d) doc.

:::note[Version]
This guide is up-to-date with Godot 4.2 stable official release but will most likely work with any 4.x release.
:::

We'll be making a complete game in which the player defends an objective against constantly spawning enemies, with both a lose and win condition.

## Making the project
Unsure if these sections are needed as they're covered by the other 3D Doc? Could merge them? Or just pick up where the other one ends.
## Working with the 3D Viewport
Unsure if these sections are needed as they're covered by the other 3D Doc? Could merge them? Or just pick up where the other one ends.

## Creating a first person controller

:::note[Godot Documentation]
Godot Documentation for nodes discussed in this section: 

[StaticBody3D](https://docs.godotengine.org/en/stable/classes/class_staticbody3d.html) [MeshInstance3D](https://docs.godotengine.org/en/stable/classes/class_meshinstance3d.html) [CollisionShape3D](https://docs.godotengine.org/en/stable/classes/class_collisionshape3d.html) 
[CharacterBody3D](https://docs.godotengine.org/en/stable/classes/class_characterbody3d.html)
:::

Let's set up a basic character controller. Thankfully, Godot makes this easy for us and actually has a template script that'll let us move around.

### Scene Setup

First, lets give ourselves something to stand on.

1. Create a **Node3D** and name it something like 'World' or 'Level' this'll be the root of our whole scene.
2. Create a **StaticBody3D** and give it two child nodes, a **MeshInstance3D** and a **CollisionShape3D.** The mesh provides visuals for our floor, while the collisionShape is what we actually stand on. 
3. Select the **MeshInstance3D** and over on the right, in the inspector, assign its Mesh property to be a **PlaneMesh**
4. Select the **CollisionShape3D** and set its 'Shape' property to a new **BoxShape3D**
5. Select **CollisionShape3D** in the scene tree and use the orange dots in the viewport to shape the **BoxShape3D** to the same shape and size as the plane. Although it's good to leave it a little thicker than the plane, to stop us from falling through.
6. Click on the **StaticBody3D** and find the **Transform** over on the right. Increase any of the Scale values to something like 20. They'll all increase as they're 'linked' (Denoted by the chain on the right)

Great! Now our player has something to stand on. Lets add our Character.

### Adding the Character

1. Create a **CharacterBody3D** as a child of our root world node. Right click on it, and save branch as a new scene. This allows us to easily modify our player. Name it something like 'Player' or 'Character'
2. Find the newly created scene in the file explorer, or click on the "scene" icon, to open our scene.
2. Give it a **Camera3D** and a **CollisionShape3D** as children. Given the collisionShape a capsule shape using the inspector. The CollisionShape is what'll allow us to collide with the floor.
3. Right click on the **CharacterBody3D** and assign a script, leave everything as default and hit load. This is because we're using the script Godot provides for us. For now we won't be messing with this, you can click 3D at the top to return to the scene view.
5. Lets click on the **Camera3D** over on the left, and use the green arrow in the viewport to move it on the Y-axis to wherever you think the 'eyes' of your character should be, based on the capsule.
6. Make sure you save the scene, using **CTRL + S** or using the File menu in the top left.
7. Let's go back to our main scene now, using the tab with the name you used for your 'World' Scene. You'll probably notice that the player is halfway in the floor, which is not ideal. Just click on the root **CharacterBody3D** Node and move to up on the Y-Axis

Great! Let's test our game! Hit the **Run Project** Button and try moving around!
You'll probably notice two things:

1. We can't look around
2. The default controls use the arrow keys to move, when WASD is generally standard.

Don't worry, we'll fix these issues shortly.

#### StaticBody vs RigidBody?

You may have noticed we used a **StaticBody3D** Object. If you've ever used a 3D game engine before, you've likely heard of 'Static Bodies' and 'Rigid Bodies' but what's the difference?

Both exist as part of the games Physics simulation, and are capable of physically affecting other objects. The main difference is how they're effected by other objects. 

A Static Body cannot be moved by any other physics object, hence 'static' (Though scripts can still move them) Think a solid wall, or tree. Most objects in a given scene that want a player to colide with, will be Static Bodies.

A Rigid Body is the opposite, and can bounce and fall and move based on collisions. If one rigidbody hits another, it'll make it move, based on things like velocity and gravity. Think a soccer ball colliding with another.

#### Some things to try

1. Try deleting the collision shape from the ground or the player, what happens?

2. Open up the Script for the character movement, try changing the speed up or down, what happens?


## Improving the character controller
:::note[Godot Documentation]
Godot Documentation for nodes discussed in this section: 

[Input Map](https://docs.godotengine.org/en/stable/classes/class_inputmap.html) [Input Examples](https://docs.godotengine.org/en/stable/tutorials/inputs/input_examples.html) 
[Camera3D](https://docs.godotengine.org/en/stable/classes/class_camera3d.html) [Exports](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_exports.html)
:::
### Changing the Controls

First, lets fix our control scheme. If you want, you can leave your controls as the arrowkeys, or make them whatever you like. But it's a good idea to understand how to change them.
Thankfully, Godot has a robust Input System. Let's open our input settings by going to **Project > Project Settings... > Input Map** from the top left menu. Using the 'Add new Action' field, add five actions.
'Forward', 'Backward', 'Left', 'Right', and 'Jump'

Using the '+' button next to each direction, search for the key you want to assign for each. Let's do 'W', 'S', 'A', 'D', and 'Space' respectively. Makes sure you're not holding shift or control, otherwise these will become part of the input.

Great! But if you hit play now, you'll notice nothing has changed. This is because we need to tell our controller script to listen for these inputs. 

Let's go back to our character controller script and change out the default inputs, to our new ones.

:::note[Case sensitivity]
The names of these inputs are case sensitive, so make sure they match exactly what you called them!
:::

Lets change

```gdscript
var input_dir = Input.get_vector("ui_left", "ui_right", "ui_up", "ui_down")
```

to

```gdscript
var input_dir = Input.get_vector("Left", "Right", "Forward", "Back")
```

and 

```gdscript
if Input.is_action_just_pressed("ui_accept") and is_on_floor():
```

to 

```gdscript
if Input.is_action_just_pressed("Jump") and is_on_floor():
```
Great! Run your game and test these changes, make sure every movement input, and jump works, and double-check any that don't.

In the future, if you want to change the controls, all you'll have to do is change the assigned inputs under the Input Map.

### Fixing the Camera

The final thing we need to do to have a fully functional Character controller, is to get our camera moving!

If we were working on a large long-term project we would likely want to make this its own script, but lets keep things simple for now and just add it to our character controller script.

Let's open our character controller script by clicking on the CharacterBody3D node and opening the script tab.

below the existing variable declarations, lets add a new line.

```gdscript
@export var camera:Camera3D
```
The export tag allows us to assign variables/nodes from within the inspector. If you've used unity, this works the same as [SerializeField.] We'll take another look at this soon.

We'll need two variables to keep track of our rotation, and control our mouse sensitivity, add these underneath the other variable declarations.

```gdscript
var camera_rotation = Vector2(0, 0)
var mouse_sensitivity := 0.005
```
You've probably noticed by now, that when launching the game, the mouse stays visible, when most games 'capture' the mouse. Thankfully this is an easy addition using godots Input system. 

```gdscript
func _ready() -> void:
  Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
  ```

The **_ready()** function is called by godot when the object is first instantiated, so its a great place to do things like this.

Trying running the game now, you'll notice your mouse is gone! To quit you can alt+tab out, and press stop in the top right menu.

But let's make sure we can get our mouse back.

```gdscript
func _input(event) -> void:
  # If escape is pressed reveal the mouse
  if event.is_action_pressed("ui_cancel"):
    Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
```
The **_input(event)** function is called by godot whenever input is detected, this lets us check what was pressed. In this case we'll be checking for 'ui_cancel'. You may notice that we didn't create any input called 'ui_cancel'
This is another one of Godot's default inputs, and is bound to 'esc'

Great! Let's try running our game again, using Esc to get our mouse back.

Because this function checks for input, we can use it to tell if our mouse has moved, as Godot considers this input.

Let's add some more to the **_input(event)** function.

```gdscript
  if event is InputEventMouseMotion:
    # Get how much the mouse has moved and pass it onto the camera_look function
    var relative_position = event.relative * mouse_sensitivity
    camera_look(relative_position)
```

meaning the full function would look like this:

```gdscript
func _input(event) -> void:
  # If escape is pressed reveal the mouse
  if event.is_action_pressed("ui_cancel"):
    Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)

  # Get the mouse movement
  if event is InputEventMouseMotion:
    # Get how much the mouse has moved and pass it onto the camera_look function
    var relative_position = event.relative * mouse_sensitivity
    camera_look(relative_position)
```

The **event.relative** variable tracks the difference in the position of the mouse from the last frame, which tells us how much the mouse has moved. We then multiply this by our sensitivity value.

You'll notice we've called a method called **camera_look()** that doesn't exist, we'll create this now.

```gdscript
func camera_look(movement: Vector2) -> void:
  # Add how much the camera has moved to the camera rotation
  camera_rotation += movement
  # Stop the player from making the camera go upside down by looking too far up and down
  camera_rotation.y = clamp(camera_rotation.y, deg_to_rad(-90), deg_to_rad(90))

  # Reset the transform basis
  transform.basis = Basis()
  main_camera.transform.basis = Basis()

  #The player and camera needs to rotate on the x and only the camera should rotate on the y
  rotate_object_local(Vector3.UP, -camera_rotation.x)
  main_camera.rotate_object_local(Vector3.RIGHT, -camera_rotation.y)
```

This looks complicated, but really what's happening is:
1. We keep track of the total amount the player is rotated by
2. We ensure that the Y rotation can't go over a certain value, to prevent us doing flips with the camera (In this case the value has to stay between -90 and 90 degrees)
3. We zero the basis' of the camera and player, to making adding rotation easy
4. We rotate the Player on the X-axis, and the Camera on the Y-axis. These are seperated. as if we simply rotated our player, as we looked up, our player would lean backwards until it falls over.

Finally, we need to revisit that ***@export*** statement. make sure you save your script, then go back to our Player scene. Click on the CharacterBody3D and you'll notice that over on the right in the inspector, is a slot called 'Camera'
Just drag and drop our Character's camera from the left panel, over into the inspector, and our camera is assigned!

When we play our game, we can properly walk and look around! Now its time to get some gameplay in our game!

#### Some things to try

1. Try increasing and decreasing the Camera sensitivity, change it to a value that feels best for you.
2. See if you can change the button we use to get our mouse back to something else

## Creating an Objective
:::note[Godot Documentation]
Godot Documentation for nodes discussed in this section: 

[Signals](https://docs.godotengine.org/en/stable/getting_started/step_by_step/signals.html) [CollisionShape3D](https://docs.godotengine.org/en/stable/tutorials/physics/collision_shapes_3d.html) 
[Area3D](https://docs.godotengine.org/en/stable/classes/class_area3d.html#class-area3d) [Groups](https://docs.godotengine.org/en/stable/tutorials/scripting/groups.html)

:::

(Almost) Every game needs an objective! Something for the player to work towards, and to keep them playing. For our game, we'll be creating something that the player will defend from waves of enemies. In my version of the game, this will be a Crystal,
but yours can be anything! 

### Objective Scene

Let's start by going back to our main scene, and giving the root node a new child with the **Node3D** Type. Call it something like "Objective". Then, like we did with the player, we'll save it as a new scene, and open it.

Our scene will need a few things: 
1. A **StaticBody3D** Object, with a **CollisionShape3D** to prevent the player walking through it
2. A **MeshInstance3D** To give the objective a model
3. An **Area3D** with a **CollisionShape3D** to detect when enemies 'hit' it. You can think of an **Area3D** as a way to detect when an object enters an Area, using the **CollisionShape3D** to define the area 

Your **MeshIstance3D** can be whatever shape you prefer. However make sure your **StaticBody3D** has a **CollisionShape3D** that roughly matches your **MeshInstance3D**.

Leave the **CollisionShape3D** attached the **Area3D** as a circle or square, we'll be coming back to this later.

Your scene hierarchy should look something like this:

[TODO: Image]

And thats it! Everything else will be handled by our script!

### Health Script

## Creating Enemies

### Enemy Scene

### Enemy Script

## Losing

## Fighting Back

## Winning

## Tying it all together with UI

## Where to next