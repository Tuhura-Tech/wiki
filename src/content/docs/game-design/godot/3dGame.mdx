---
title: Making a 3D Game
description: This page works through creating a full 3D game step by step
sidebar:
    order: 5
---

This is a guide to making a 3-Dimensional game in [Godot](https://godotengine.org/). If you are unfamiliar with Godot, check out the [Godot basics](/game-design/godot/basics) doc and the [3D fundmentals](/game-design/godot/3d) doc.

:::note[Version]
This guide is up-to-date with Godot 4.2 stable official release but will most likely work with any 4.x release.
:::

We'll be making a game in which the player defends an objective against constantly spawning waves enemies, with both a lose and win condition. Designed to act as a foundation for your own ideas, allowing for easy expansion and polish.

## Making the project
Setup a Basic 3D project, using the Forward+ Renderer. Create a Node3D as the root, and call it something like 'World'
[Todo: Image]
## Working with the 3D Viewport
[Todo: Explain the ways working in 3d space differs from working in 2D Space]

## Creating a first person controller

:::note[Godot Documentation]
Godot Documentation for nodes discussed in this section: 

[StaticBody3D](https://docs.godotengine.org/en/stable/classes/class_staticbody3d.html) [MeshInstance3D](https://docs.godotengine.org/en/stable/classes/class_meshinstance3d.html) [CollisionShape3D](https://docs.godotengine.org/en/stable/classes/class_collisionshape3d.html) 
[CharacterBody3D](https://docs.godotengine.org/en/stable/classes/class_characterbody3d.html)
:::

Let's set up a basic character controller. Thankfully, Godot makes this easy for us and actually has a template script that'll let us move around.

### Scene Setup

First, lets give ourselves something to stand on.

1. Create a **Node3D** and name it something like 'World' or 'Level' this'll be the root of our whole scene.
2. Create a **StaticBody3D** and give it two child nodes, a **MeshInstance3D** and a **CollisionShape3D.** The mesh provides visuals for our floor, while the collisionShape is what we actually stand on. 
3. Select the **MeshInstance3D** and over on the right, in the inspector, assign its Mesh property to be a **PlaneMesh**
4. Select the **CollisionShape3D** and set its 'Shape' property to a new **BoxShape3D**
5. Select **CollisionShape3D** in the scene tree and use the orange dots in the viewport to shape the **BoxShape3D** to the same shape and size as the plane. Although it's good to leave it a little thicker than the plane, to stop us from falling through.
6. Click on the **StaticBody3D** and find the **Transform** over on the right. Increase any of the Scale values to something like 20. They'll all increase as they're 'linked' (Denoted by the chain on the right)

Great! Now our player has something to stand on. Lets add our Character.

### Adding the Character

1. Create a **CharacterBody3D** as a child of our root world node. Right click on it, and save branch as a new scene. This allows us to easily modify our player. Name it something like 'Player' or 'Character'
2. Find the newly created scene in the file explorer, or click on the "scene" icon, to open our scene.
2. Give it a **Camera3D** and a **CollisionShape3D** as children. Given the collisionShape a capsule shape using the inspector. The CollisionShape is what'll allow us to collide with the floor.
3. Right click on the **CharacterBody3D** and assign a script, leave everything as default and hit load. This is because we're using the script Godot provides for us. For now we won't be messing with this, you can click 3D at the top to return to the scene view.
5. Lets click on the **Camera3D** over on the left, and use the green arrow in the viewport to move it on the Y-axis to wherever you think the 'eyes' of your character should be, based on the capsule.
6. Make sure you save the scene, using **CTRL + S** or using the File menu in the top left.
7. Let's go back to our main scene now, using the tab with the name you used for your 'World' Scene. You'll probably notice that the player is halfway in the floor, which is not ideal. Just click on the root **CharacterBody3D** Node and move to up on the Y-Axis

As a final touch, lets add a **DirectionalLight3D** and rotate it to face downwards so that we can see!

Great! Let's test our game! Hit the **Run Project** Button and try moving around!
You'll probably notice two things:

1. We can't look around
2. The default controls use the arrow keys to move, when WASD is generally standard.

Don't worry, we'll fix these issues shortly.

#### StaticBody vs RigidBody?

You may have noticed we used a **StaticBody3D** Object. If you've ever used a 3D game engine before, you've likely heard of 'Static Bodies' and 'Rigid Bodies' but what's the difference?

Both exist as part of the games Physics simulation, and are capable of physically affecting other objects. The main difference is how they're effected by other objects. 

A Static Body cannot be moved by any other physics object, hence 'static' (Though scripts can still move them) Think a solid wall, or tree. Most objects in a given scene that want a player to colide with, will be Static Bodies.

A Rigid Body is the opposite, and can bounce and fall and move based on collisions. If one rigidbody hits another, it'll make it move, based on things like velocity and gravity. Think a soccer ball colliding with another.

#### Some things to try

1. Try deleting the collision shape from the ground or the player, what happens?

2. Open up the Script for the character movement, try changing the speed up or down, what happens?


## Improving the character controller
:::note[Godot Documentation]
Godot Documentation for nodes discussed in this section: 

[Input Map](https://docs.godotengine.org/en/stable/classes/class_inputmap.html) [Input Examples](https://docs.godotengine.org/en/stable/tutorials/inputs/input_examples.html) 
[Camera3D](https://docs.godotengine.org/en/stable/classes/class_camera3d.html) [Exports](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_exports.html)
:::
### Changing the Controls

First, lets fix our control scheme. If you want, you can leave your controls as the arrowkeys, or make them whatever you like. But it's a good idea to understand how to change them.
Thankfully, Godot has a robust Input System. Let's open our input settings by going to **Project > Project Settings... > Input Map** from the top left menu. Using the 'Add new Action' field, add five actions.
'Forward', 'Backward', 'Left', 'Right', and 'Jump'

Using the '+' button next to each direction, search for the key you want to assign for each. Let's do 'W', 'S', 'A', 'D', and 'Space' respectively. Makes sure you're not holding shift or control, otherwise these will become part of the input.

Great! But if you hit play now, you'll notice nothing has changed. This is because we need to tell our controller script to listen for these inputs. 

Let's go back to our character controller script and change out the default inputs, to our new ones.

:::note[Case sensitivity]
The names of these inputs are case sensitive, so make sure they match exactly what you called them!
:::

Lets change

```gdscript
var input_dir = Input.get_vector("ui_left", "ui_right", "ui_up", "ui_down")
```

to

```gdscript
var input_dir = Input.get_vector("Left", "Right", "Forward", "Back")
```

and 

```gdscript
if Input.is_action_just_pressed("ui_accept") and is_on_floor():
```

to 

```gdscript
if Input.is_action_just_pressed("Jump") and is_on_floor():
```
Great! Run your game and test these changes, make sure every movement input, and jump works, and double-check any that don't.

In the future, if you want to change the controls, all you'll have to do is change the assigned inputs under the Input Map.

### Fixing the Camera

The final thing we need to do to have a fully functional Character controller, is to get our camera moving!

If we were working on a large long-term project we would likely want to make this its own script, but lets keep things simple for now and just add it to our character controller script.

Let's open our character controller script by clicking on the CharacterBody3D node and opening the script tab.

below the existing variable declarations, lets add a new line.

```gdscript
@export var camera:Camera3D
```
The export tag allows us to assign variables/nodes from within the inspector. If you've used unity, this works the same as [SerializeField.] We'll take another look at this soon.

We'll need two variables to keep track of our rotation, and control our mouse sensitivity, add these underneath the other variable declarations.

```gdscript
var camera_rotation = Vector2(0, 0)
var mouse_sensitivity := 0.005
```
You've probably noticed by now, that when launching the game, the mouse stays visible, when most games 'capture' the mouse. Thankfully this is an easy addition using godots Input system. 

```gdscript
func _ready() -> void:
  Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
  ```

The **_ready()** function is called by godot when the object is first instantiated, so its a great place to do things like this.

Trying running the game now, you'll notice your mouse is gone! To quit you can alt+tab out, and press stop in the top right menu.

But let's make sure we can get our mouse back.

```gdscript
func _input(event) -> void:
  # If escape is pressed reveal the mouse
  if event.is_action_pressed("ui_cancel"):
    Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
```
The **_input(event)** function is called by godot whenever input is detected, this lets us check what was pressed. In this case we'll be checking for 'ui_cancel'. You may notice that we didn't create any input called 'ui_cancel'
This is another one of Godot's default inputs, and is bound to 'esc'

Great! Let's try running our game again, using Esc to get our mouse back.

Because this function checks for input, we can use it to tell if our mouse has moved, as Godot considers this input.

Let's add some more to the **_input(event)** function.

```gdscript
  if event is InputEventMouseMotion:
    # Get how much the mouse has moved and pass it onto the camera_look function
    var relative_position = event.relative * mouse_sensitivity
    camera_look(relative_position)
```

meaning the full function would look like this:

```gdscript
func _input(event) -> void:
  # If escape is pressed reveal the mouse
  if event.is_action_pressed("ui_cancel"):
    Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)

  # Get the mouse movement
  if event is InputEventMouseMotion:
    # Get how much the mouse has moved and pass it onto the camera_look function
    var relative_position = event.relative * mouse_sensitivity
    camera_look(relative_position)
```

The **event.relative** variable tracks the difference in the position of the mouse from the last frame, which tells us how much the mouse has moved. We then multiply this by our sensitivity value.

You'll notice we've called a method called **camera_look()** that doesn't exist, we'll create this now.

```gdscript
func camera_look(movement: Vector2) -> void:
  # Add how much the camera has moved to the camera rotation
  camera_rotation += movement
  # Stop the player from making the camera go upside down by looking too far up and down
  camera_rotation.y = clamp(camera_rotation.y, deg_to_rad(-90), deg_to_rad(90))

  # Reset the transform basis
  transform.basis = Basis()
  main_camera.transform.basis = Basis()

  #The player and camera needs to rotate on the x and only the camera should rotate on the y
  rotate_object_local(Vector3.UP, -camera_rotation.x)
  main_camera.rotate_object_local(Vector3.RIGHT, -camera_rotation.y)
```

This looks complicated, but really what's happening is:
1. We keep track of the total amount the player is rotated by
2. We ensure that the Y rotation can't go over a certain value, to prevent us doing flips with the camera (In this case the value has to stay between -90 and 90 degrees)
3. We zero the basis' of the camera and player, to making adding rotation easy
4. We rotate the Player on the X-axis, and the Camera on the Y-axis. These are seperated. as if we simply rotated our player, as we looked up, our player would lean backwards until it falls over.

Finally, we need to revisit that ***@export*** statement. make sure you save your script, then go back to our Player scene. Click on the CharacterBody3D and you'll notice that over on the right in the inspector, is a slot called 'Camera'
Just drag and drop our Character's camera from the left panel, over into the inspector, and our camera is assigned!

When we play our game, we can properly walk and look around! Now its time to get some gameplay in our game!

#### Some things to try

1. Try increasing and decreasing the Camera sensitivity, change it to a value that feels best for you.
2. See if you can change the button we use to get our mouse back to something else

## Creating an Objective
:::note[Godot Documentation]
Godot Documentation for nodes discussed in this section: 

[Signals](https://docs.godotengine.org/en/stable/getting_started/step_by_step/signals.html) [CollisionShape3D](https://docs.godotengine.org/en/stable/tutorials/physics/collision_shapes_3d.html) 
[Area3D](https://docs.godotengine.org/en/stable/classes/class_area3d.html#class-area3d) [Groups](https://docs.godotengine.org/en/stable/tutorials/scripting/groups.html)

:::

(Almost) Every game needs an objective! Something for the player to work towards, and to keep them playing. For our game, we'll be creating something that the player will defend from waves of enemies. In my version of the game, this will be a Crystal,
but yours can be anything! 

### Objective Scene

Let's start by going back to our main scene, and giving the root node a new child with the **Node3D** Type. Call it something like "Objective". Then, like we did with the player, we'll save it as a new scene, and open it.

Our scene will need a few things: 
1. A **StaticBody3D** Object, with a **CollisionShape3D** to prevent the player walking through it
2. A **MeshInstance3D** To give the objective a model
3. An **Area3D** with a **CollisionShape3D** to detect when enemies 'hit' it. You can think of an **Area3D** as a way to detect when an object enters an Area, using the **CollisionShape3D** to define the area 

Your **MeshIstance3D** can be whatever shape you prefer. However make sure your **StaticBody3D** has a **CollisionShape3D** that roughly matches your **MeshInstance3D**.

Leave the **CollisionShape3D** attached the **Area3D** as a circle or square, we'll be coming back to this later.

Your scene hierarchy should look something like this:

[TODO: Image]

And thats it! Everything else will be handled by our script!

### Health Script

Before we get into our script, let's think about what we need it to do:

1. Detect if an enemy touches the objective
2. If an enemy does, reduce Health
3. If health reaches 0, do something

Step 1. Will be the most complicated, but thankfully Godot has a lot of features that'll make it easy for us. 

Let's attach a script to the root node of our Objective, calling it something like "objective_health"

Let's first of all declare a new variable to track our health.

```gdscript
var health = 3
```

Mine starts at 3, but yours can start at anything (Greater than 0)

Now, let's start detecting if an enemy has colided with us.

Let's start by declaring a new function that'll be called when something enters the **Area3D** around the Objective.

```gdscript
func entered(area: Area3D):
```

Here, 'area' represents the other object that has entered the objective, as Area3Ds only detect collisions with other Area3Ds.
Let's check if it's an enemy.

```gdscript
if(area.is_in_group("enemy")):
```

If it is, let's subtract health. To keep things simple, for now we'll just print a message if we've died. We'll expand this to allow for different damage amounts, and an actual lose state, later.

```gdscript
func entered(area: Area3D):
    if(area.is_in_group("enemy")):
        health = health - 1
        if(health <= 0):
        print("Game Over!")
```

Great! Let's save our script, and that's it done for now!

Now, we could have just as easily attached the 'Health' script to our player, but in this game, our player isn't our enemy's target. However, if you want to change that, by the end of this guide, you should be able to figure that out fairly easily!

#### What's a group?

Think of a group as a way to, well, group objects in our game. In this case, if we have multiple types of enemies later, we don't need to check if we've collided with any of them,
we can simply check if they're in the 'Enemy' group. We'll go over adding things to groups when we create an enemy.


#### Signals

We've created our function, but what calls it? We could create a convoluted way of checking if another object is in the bounds of our objective, but thankfully for us, our **Area3D** already
regesters whenever anything enters it, all we have to do is connect the functions. We'll do this using signals!

If we click our **Area3D** and on the right, change from the **Inspector** to the **Node** Tab. From here we can access the Node's signals.
Here we have all the Signals this Node can output, we can attach our function to one of these, allowing it to 'listen' for the specific condition. Think of it like
setting up a radar dish to listen for one very specific sound. In this case, we want the **area_entered** signal. You'll notice it outputs an **Area3D** which is why we set up our function to take an **Area3D.**
Had we not done this, we wouldn't be able to connect the signal.

1. Double click on the **area_entered** signal.
2. Select our 'Objective' root node.
3. Click 'Pick' on the bottom right
4. Select our 'entered' function.
5. Click 'OK'
6. Click 'Connect'

If our function isn't showing as an option, make sure you've saved the script, and that the variable input for the function is correct.

Great! Now whenever something enters our objective, it'll call this script!

Signals are an amazing way to connect scripts without having to store a Node reference, you can even write your own signal outputs! However that's out of scope for this guide, if you're interested, read over the [Godot Documentation for Signals](https://docs.godotengine.org/en/stable/getting_started/step_by_step/signals.html) 

[TODO: Image]

## Creating Enemies

:::note[Godot Documentation]
Godot Documentation for nodes discussed in this section: 

[Material](https://docs.godotengine.org/en/stable/classes/class_material.html) [3D Transforms](https://docs.godotengine.org/en/stable/tutorials/3d/using_transforms.html) 
[Area3D](https://docs.godotengine.org/en/stable/classes/class_area3d.html#class-area3d) [Groups](https://docs.godotengine.org/en/stable/tutorials/scripting/groups.html)
[Interpolation](https://docs.godotengine.org/en/stable/tutorials/math/interpolation.html)

:::

Let's start making the antagonists of this game, our enemies! 
As you've hopefully come to expect by now, we'll start by making a scene!

Although as you'll soon find out, this is most important for or enemy, as we'll be creating more instances of this scene through code.

### Enemy Scene

Let's again give the World root node a new child of a Node3D, right click it, save as scene. Call it something like "enemy_a" or "enemy_1" you can always change the name later.
It's good to get your head around these steps, as you'll be doing them often in any project you make! This is the last time this guide will go over them in detail, but if you get confused, feel free to look
back at one of the earlier steps.

Take a second to try and think what Node's we'll likely need for our enemy.


We're going to need:
1. Something to visibly represent the enemy.
2. Something to allow for our enemy to colide with the objective so that they can deal damage.

We don't necessarily want our enemy to physically collide with anything however, so we'll skip giving them a Static or Rigid Body.

Here's how I've laid out my Enemy Scene, yours should hopefully look similar! If it doesn't don't worry, feel free to change it to look like mine.

[TODO: Image]

Remember to assign shapes to your **MeshInstance3D** and your **CollisionShape3D**

So that he player can differentiate between our enemies and the rest of our level, let's add a material to make the enemy a different colour.
Materials can be used to alter the apperance of meshes in our game, from simple materials that just change colour, to advanced materials that apply custom textures, different material types, or even shaders.

But for now, let's keep it simple. 

Click on the **MeshInstance3D** and on the right, in the inspector, click on the **Material Surface Override** Button, in the '0' slot, where it says empty, add a new **StandardMaterial3D**

Click on the white sphere that's appeared. Feel free to experiment with any and all of the settings here, but for the colour, click on **Albedo.** Click on the white Rectangle, and experiment with the colour, i'll be making my enemy red.

[TODO: Image]

### Enemy Script

Great, we have our enemy, it's looking good, now we just need to get it moving! Let's add a script to the root node of the Enemy Scene. Call it 'Enemy' or something similar.

But let's first think about what we're going to need:
1. A way to control the health and speed of enemies
2. A reference to their target (The objective)
3. To face toward, and then move toward, the objective

The first step should be easy, let's add some variables! Remember the **@export** tag we used on the objective script? We'll be using that here too!
Except this time we'll be using it to allow us to easily change the variables on our enemy, without needing to edit the script. 

```gdscript
@export var health = 1
@export var speed = .5
```

If you save your script, and look in the inspector of the enemy object, you'll notice there are now two boxes, 'health' and 'speed' with their current values being set to 0 and 0.01.
You can think of the values we declared like default values, and anything we type into those boxes will overwrite them.

Let's add two more variables, which we'll use later.

```gdscript
var targetNode
var lerp_t = 0
var startPosition
```
These will only be used inside the script, so there's no need for them to be 'exports.'

In our **_ready** function, we'll get a reference to our Objective, so that our enemies can target it.

```gdscript
targetNode = get_node("%Objective")
startPosition = global_position
```

If you haven't seen it before, the '%' here donotes a unique name, to prevent us from having to put in the complete path for the objective, but this would be equivilent to something like "/root/World/Objective"
Using the '%' is great when we know we're only going to have one of something! We'll have to edit our objective slightly to make this work, but we'll do that in a moment.

For now, let's focus on our enemy. For this, we're going to be doing something called 'lerping' (Short for Interpolation) lerping is basically a smooth way to move something from one point to another,
both in 2D and 3D. All we need for a lerp is that starting position (That's why we got the enemies position in the **_ready** function) the target position (That's our objective) and a 't' value, which controls how far between the two points or object is.
the t value goes from 0 to 1, with 0 being right at the start, and 1 being right at the end. 

Let's start lerping! In our **_process** function we'll add a few lines.

```gdscript
lerp_t += delta * speed
look_at(targetNode.global_position)
global_position = lerp(startPosition, targetNode.global_position, lerp_t)
```

First, we increase our 't' value, based on Delta (The amount of time since the last frame) and our speed variable, to allow us to control the rate of the lerp.

Next, we ensure our enemy is facing toward the objective, this doesn't matter as much for my circle enemy, but if you have a more complex shape, it'll make things look better.

Then, we set the enemies global_position to the value of the lerp between its starting position, and the objective, based on the 't' value.
If you're still confused about Lerps, take a look at the [Godot Docs for Interpolation](https://docs.godotengine.org/en/stable/tutorials/math/interpolation.html)

Then, let's rap it all in an 'if' statement, to stop the lerp once the 't' value as reached 1.

```gdscript
if(lerp_t < 1):
```

Giving us a final script that looks like this:

```gdscript
extends Node3D

@export var health = 1
@export var speed = .5

var targetNode
var lerp_t = 0
var startPosition

# Called when the node enters the scene tree for the first time.
func _ready():
	targetNode = get_node("%Objective")
	startPosition = global_position
	 # Replace with function body.
	
# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta):
	if(lerp_t < 1):
		
		lerp_t += delta * speed
		look_at(targetNode.global_position)
		global_position = lerp(startPosition, targetNode.global_position, lerp_t)
```

Before we move on, there's a few more things we should do.
Go back to your main scene, right click on the Objective, and select "Access as Unique Name" this will allow for getting the Objective node with ("%Objective") However make sure the name here matches exactly the name used in the script.

[TODO: Delete Enemies]

[TODO: Talk about Global Position vs Position]

[TODO: Try messing around with speed]

### Respawning Enemies
[TODO: Singletons?]
## Fighting Back

## Losing

## Winning

## Tying it all together with UI

## Some final touches
[TODO: Link to Github repo]
## Where to next